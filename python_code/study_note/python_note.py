# 1.python中is和==的区别：
# Python中对象包含的三个基本要素，分别是：id(身份标识)、type(数据类型)和value(值)。
# is和==都是对对象进行比较判断作用的，但对对象比较判断的内容并不相同。
# is也被叫做同一性运算符，这个运算符比较判断的是对象间的唯一身份标识，也就是id是否相同。
# ==判断的是两个对象的值，即value是否相同。

# 2.python中交换两个对象的值：
# 可以直接用 a,b=b,a

# 3.判断链表中的结点是否是尾结点：
# 用node.next is None来判断

# 4.sublime的操作：
# ctrl+？ 可以给选中部分全部加#注释
# ctrl+shift+R  可以给选中代码全部改为指定格式
# ctrl+}  可以让选中部分代码整体左右移动缩进

# 5.__init__和__new__的区别：（需要强化理解？？？？）
# __new__是一个静态方法，而__init__是一个实例方法
# __new__方法会返回一个创建的实例，而__init__什么都不返回
# 只有在__new__返回一个cls的实例时，后面的__init__才能被调用
# 当创建一个新实例时调用__new__，初始化一个实例时用__init__

# 6.删除二叉树结点或链表结点：
# python中对资源的释放采用引用计数的方式，不同于C语言中可以直接free掉。
# 因此删除树或链表中的结点不能直接对结点本身采用del等操作。
# 修改结点的父结点(前后结点)的next指针，使结点本身不再被引用即可。

# 7.浅拷贝与深拷贝：
# 浅拷贝一层，深拷贝多层
# 原数据只有一层时，深浅拷贝一致且都不会随原数据的变化而变化
# 当修改多层数据的内层时，深拷贝不变，浅拷贝的内层部分会随之变化

# 8.关于逻辑运算符：
# x or y: if x is true,then x,else y   返回x或y的值
# x and y: if x is true,then y,else x   返回x或y的值
# not x    返回True或False

# 9.关于三元表达式(三元运算符)：
# 三元表达式其他语言中是 条件表达式？表达式1：表达式2
# 在python中   x=1 if 3>2 else 0

# 10.关于*args可变参数：
# 用在函数 def foo(*args)中表示可以传入任意数量个参数

# 11.关于**运算：
# a**b 表示a的b次方
# 特别的，0的0次方为1

# 12.序列类型的切片操作：
# 字符串、列表、元组等序列类型切片[start:end:step]
# 以下的切片操作均为合法类型
# list[1:-1]从第二个到最后一个
# list[::-2]以2为步长的逆序
# list[-3]倒数第三个
# list[2:13]第二个到第十三个
# list[::3]以3为步长的正序
# list[2-3]即倒数第一个

# 13.关于异常捕捉：
# try:
#     pass
# expect:
#     pass
# else:
#     pass
# finally:
#     pass
# try和except执行其中一个，else和finally无论如何都会执行

# 14.关于元组tuple:
# 创建只有一个元素的元组用a=(1,)
# 如果时a=(1)会被认为是整数类型

# 15.python中字符串的单引号，双引号，三引号的区别：
# 单引号可以直接表示字符串，但遇到字符串包含单引号时必须使用转移符才能表示
# 单引号中可以包含双引号，s1='hello,"china",world'
# 双引号（注意是"，不是'')表示的字符串中可以包含单引号，即s4="let's go" 和s5='let\'s go'相同
# 三引号可以保持多行字符串的原有格式且不需要换号符\n，三引号中可以包含单引号和双引号

# 16.关于排序算法的稳定性（两个相同值的数据排序前后顺序是否改变）：
# 稳定的：冒泡，直接插入排序，归并排序，基数排序
# 不稳定的：快排，希尔排序，简单选择排序，堆排序

# 17.关于python装饰器/修饰器：
# python装饰器本质上是一个函数，它可以协助其他函数在不修改代码的情况下增加额外的功能，装饰器的返回值也是一个函数对象。
# 装饰器是@开头且放在被装饰函数上面,例如@app.route()

# 18.关于python生成器(generator)：
# 一边循环，一边计算的机制称为生成器。例如对于很大的列表，列表元素全部创建出来会占用很大的内存空间，如果列表元素可以
# 按照某种算法推算出来，就可以在循环的过程中不断推算出后续的元素，大大节省了存储空间。
# 函数中如果出现了yield关键字，那么该函数就不再是普通函数，而是生成器函数。
# 生成器函数和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，
# 在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。
# 一个函数或者子程序都只能 return 一次，但是一个生成器能暂停执行并返回一个中间的结果,即用关键字yield来代替return。
# generator对象一般用for i in fun():来迭代输出。

 

