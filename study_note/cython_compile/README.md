# Python Compiler

> python代码预编译与源码隐藏

这是一个使用Cython预编译的方式达到代码隐藏、提升速度以满足部署甲方机器而又不希望暴露代码的目的。

本仓库打包了自动代码发现、编译、自动清理现场等源码隐藏需要用到的功能。

## 使用

#### 1. 安装依赖

需要安装c++编译器，clang或gcc等。

需要安装`cython`和`python-dev`，centos系统下可以按照如下指令安装。

```
sudo yum install python36-devel
sudo pip install cython
```

#### 2. 拷贝相关文件

将本仓库 `compile.py` 文件拷贝到项目目录下。

#### 3. 编写入口文件

源项目程序执行开始py源码文件可能存在大量逻辑，写一个新的入口py文件，将这个文件作为引用。仅执行其main函数。例如：

``` python3
# old_entry.py
...
if __name__ == '__main__': # 改写为：def main():
    ...

```

建立新的无逻辑代码的入口文件：

``` python3
# main.py
from old_entry import main
if __name__ == '__main__':
    main()
```

这个`main.py`先不需要放入工程中，防止编译时也被编译。

#### 4. 列出要编译的源码文件

以下命令会列出所有的需要编译的模块和相应的python源文件位置，而不会真实编译，请使用此命令检查系统自动代码发现结果是否正确。

```
python compile.py list_src
```

#### 5. 编译

编译出`.c`, `.o`, `.so` 文件。

```
python compile.py build_ext --inplace
```

清理编译出的内容

以下指令会清理编译出的`.c`, `.o`, `.so` 文件。恢复编译前的文件状态。此步骤在正常流程中不需要。
```
python compile.py clear_compile
```

#### 6. 清理代码和中间编译结果

```
python compile.py clear_src
```

#### 7. 新的入口文件

将之前写好的新入口`main.py`放入工程，从此入口执行程序。

## 在本仓库基础上开发
#### 1. 关于源码隐藏方法的调研

先说结论：没有找到一种兼容代码隐藏能力强而且保持了python跨平台能力的方案。望之后开发者能够继续努力。

###### 1. 基于混淆的方法

为了实现代码隐藏的目的，作者调研过一些相关的混淆方法，供以后开发者参考探讨。

以下这些方法混淆后代码不能运行。

- [Opy](https://github.com/QQuick/Opy)
- [pyminifier](https://github.com/liftoff/pyminifier)

以下方法混淆效果较差。

- [oxyry](http://pyob.oxyry.com/) 在线

因为混淆方案可以保证代码的跨平台能力，我们先考虑混淆方案。但无奈混淆方案没有可以使用的开源版本。后文有关于自制混淆器的讨论。如果之后开发混淆方案希望能有所参考。

###### 2. 基于编译的方案

- 编译为`.pyc`的方案

这种方案最大的问题是可以使用工具（ [uncompyle2](https://github.com/wibiti/uncompyle2) ）快速进行反编译，逆向之后和源码相同，无法达到隐藏目的。

- 编译为`.so`二进制包

本库使用此方法实现。[参考](https://medium.com/@xpl/protecting-python-sources-using-cython-dcd940bb188e)。
但应注意本方法的一个缺点是跨平台能力差。需要现场编译或在虚拟机中编译后迁移。


#### 2. 自制混淆器

###### 1. 混淆级别与类型

- local作用域变量：
上文讨论的在线混淆器混淆效果差，既是因为其只能单文件混淆。这种混淆方法的最大问题在于，自己代码文件之间的变量名称，模块名称，模块方法名都不能混淆。仅能混淆方法参数名，混淆后的可读性还是很好。
但这种方法好做，仅考虑单源码文件即可。

- 工程内混淆：
与第一点有别，此方法混淆工程内代码对自己py文件的引用，这样就可以混淆自定义的文件夹名（模块名）、文件名（模块名）、类名、方法名，达到可用的混淆能力。
但是这种方法实现难度很大，主要体现在区分本工程内对象（类）和系统（第三方）的对象（类），既什么可以混淆，什么不可混淆，要做到这一点并且混淆后不出错误，可能需要一个非常强大的类型推断，做成这个东西的难度-收益比，值得考虑。

- 字符串混淆：
此点从opy项目中借鉴，混淆可以将代码中使用的字符串也进行带盐加密，之后运行时使用特定解密函数解密，可以达到很好的混淆效果。实现也较简单。

###### 2. 方法

python自带的句法树解析库 `ast` 和 `astor` 是文件代码树解析和从代码树恢复代码文件的好工具，在开发中可以用到，比自己匹配正则要方便很多。

作者尝试构造混淆器（最终因改动方案未完成），下面记录项目架构设计的一些细节。

```
1. 兼容ast的树节点，另构造"目录节点"、"文件节点"，因为他们也是python中的模块寻址名，是工程整体混淆中需要修改的名。
2. 将混淆分为 收集所有"名"，判断哪些名可以修改、统一修改三步。
3. 使用栈结构维护当前的名字系统，进入函数定义后还会出现覆盖现象也是需要考虑的。
4. 想推断正确所有参数类型在动态语言中是不可能的，不能推断的要小心其调用的方法是不能改名的。
```


