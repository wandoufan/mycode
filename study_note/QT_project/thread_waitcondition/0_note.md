# 使用唤醒条件QWaitCondition实现多线程同步

## 基本功能
还是模拟投掷骰子，在mutiple_thread项目的基础上进行了修改：

1. 子线程1：QThreadProducer
"生产者"线程，用来生产数据，即掷骰子产生点数
去掉了开始和暂停功能，线程一启动就连续地掷骰子

2. 子线程2：QThreadConsumer
"消费者"线程，用来消费数据，把读取骰子的点数，用发射信号的方式送给主线程进行显示

3. 主线程：Dialog
主线程，用来接收并显示"消费者"线程传递来的数据

4. 主线程和消费者之间的同步方式
采用信号与槽的机制，消费者线程拿到新数据之后发出信号，主线程接收信号以及数据  

5. 生产者和消费者之间的同步方式
生产者产生新的数据后通过wakeOne/wakeAll()唤醒消费者  
消费者被唤醒后，从wait()中退出，然后通过生产者类对象来调用生产者的数据接口，从而获得新数据  
备注：生产者和消费者之间没有必要使用信号与槽或不断循环读取的方式来传递数据  