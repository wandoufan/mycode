# 主要记录数据结构的基本知识点：


## 数据结构的基本概念
* 数据结构是相互之间存在一种或多种特定关系的数据元素的集合
* 数据结构包含三个方面的要素：

* 1.逻辑结构，即数据元素之间的逻辑关系，主要包括：
* 1.1线性结构(线性表，栈，队列，数组等)
* 1.2非线性结构(集合，一般树，二叉树，有向图，无向图)

* 2.存储结构，即计算机存储对于逻辑结构的具体实现，主要包括：
* 2.1顺序存储，把逻辑上相邻的元素存储在物理位置上也相邻的存储单元里，元素之间的关系由存储单元的邻接关系来体现
* 优点是可以实现随机存取，每个元素占用最少的存储空间；缺点是只能使用相邻的一整块存储单元，会产生较多的碎片
* 2.2链式存储，不要求逻辑上相邻的元素在物理位置上也相邻，用指示元素存储位置的指针来表示元素之间的逻辑关系
* 优点是不会产生碎片，充分利用存储空间；缺点是只能实现顺序存取，需要使用额外的空间来存储指针
* 2.3索引存储，在存储元素信息的同时还建立附加索引表
* 优点是检索速度很快；缺点是需要额外存储索引表，另外增删数据时要同步修改索引表
* 2.4散列存储，根据元素的关键字直接计算出该元素的存储地址，又称为hash存储
* 优点是检索和增删数据速度都很快；缺点是散列函数选取不当可能会造成存储单元冲突

* 3.数据运算，包括运算的定义和实现
* 运算的定义是针对逻辑结构的，指出运算的功能
* 运算的实现是针对存储结构的，指出运算的具体操作步骤


## 线性表
* 线性表是n个(n>=0)具有相同数据类型的数据元素构成的有限序列
* 线性表逻辑上线性有序 ，表中元素个数有限
* 按存储结构可以分为顺序表和链表
* 按逻辑结构可以分为栈和队列，栈和队列本质上都是操作受限的线性表


## 顺序表
* 采用顺序存储的线性表称为顺序表，采用地址连续的存储单元依次存储线性表中的元素
* 顺序表可以实现随机存取，但插入和删除时需要移动大量元素
* 采用按值查找，无序的顺序表时间复杂度为O(n)
* 采用按值查找，有序的顺序表可以采用折半查找，时间复杂度为O(log2n)
* 采用按序号查找，顺序表可以直接随机访问，时间复杂度为O(1)


## 链表
* 采用链式存储的线性表称为链表，不需要使用地址连续的存储单元
* 解决了顺序表增删操作效率低的问题，而且不会产生碎片
* 链表是非随机存储的结构，只能依次顺序访问每个元素
* 1.单链表
* 单链表中每个结点除了存放元素自身的数据之外，还需要存放一个指向其后继的指针next
* 采用头指针来标识一个单链表，头指针指向第一个结点，空表的头指针为Null
* 为了方便在单链表尾部查询增加结点，可以在设置一个尾指针指向最后一个结点
* 可以在单链表第一个结点之前附加一个头结点，头结点可以用来存储表长等信息，指针指向第一个结点
* 采用按序号查找结点的时间复杂度为O(n)
* 采用按值查找结点的时间复杂度为O(n)
* 2.双链表
* 双链表中每个结点有两个指针prior和next，分别指向其前驱结点和后继结点
* 双链接解决了单链表访问前驱结点效率低的问题，插入和删除结点的时间复杂度为O(1)
* 3.循环链表
* 循环单链表最后一个结点的指针不是null，而是指向了头结点，因此循环单链表中没有指针为null的结点
* 循环双链表第一个结点的prior指针还要指向尾结点
* 4.静态链表
* 静态链表借助数组来描述线性表的链式存储结构，指针是结点的相对地址(数组下标)，需要使用连续内存空间

### 顺序表和链表的比较
* 1.存取方式
* 顺序表可以顺序存取，也可以随机存取；链表只能顺序存取，
* 2.逻辑结构和存储结构
* 顺序表中逻辑上相邻元素的物理存储位置也相邻；链表中逻辑上相邻元素的物理存储位置不一定相邻
* 3.空间分配
* 顺序表需要占用连续的存储空间；链表可以利用碎片空间，操作更加灵活
* 4.使用选择
* 一般对于存储规模可以预估且较为稳定的数据选择顺序表；对有频繁插入、删除操作的数据选择链表


## 栈(stack)
* 栈是只允许在一端进行插入和删除操作的线性表，具有后进先出的特性
* 其中栈顶(top)是允许进行插入和删除的一端，栈底(bottom)是不允许进行插入和删除的一端
* 1.顺序栈
* 使用顺序存储的栈称为顺序栈，采用连续的存储空间，空间预估不准可能会发生栈溢出
* 2.链栈
* 采用链式存储的栈称为链栈，可以多个栈共享存储空间，不会产生栈溢出的问题
* 3.共享栈
* 两个栈的栈底设置为共享空间的两端，仅当两个栈顶指针相邻时判断为栈满，可以更有效的利用空间
* 4.栈的应用
* 栈的主要应用包括表达式中括号的匹配，计算后缀表达式，计算递归函数等


## 队列(queue)
* 队列是只允许在一端插入，在另一端删除的线性表，具有先进先出的特性
* 其中队首(front)是允许删除的一端，队尾(rear)是允许插入的一端
* 1.顺序队列
* 采用连续存储空间，设置两个指针front和rear，分别指向队头元素和队尾元素
* 顺序队列在元素出队时指针会不断移动，最终可能造成假溢出的问题
* 2.循环队列
* 把顺序队列在逻辑上设置为一个环状的空间，称为循环队列，可以解决顺序队列的假溢出问题
* 3.链队列
* 采用链式存储的队列称为链队列，适合于数据元素变动较大的情况，不存在队列满产生溢出的问题
* 4.双端队列
* 双端队列是指允许两端都可以进行入队和出队操作的队列，双端队列的两端分别称为前端和后端
* 双端队列进队时，由前端进的元素排在队列中由后端进的元素的前面
* 双端队列出队时，无论是前端还是后端出队，先出的元素排在后出的元素前面
* 输出受限的双端队列是指允许在一端进行插入和删除，但在另一端只允许插入的双端队列
* 输入受限的双端队列是指允许在一端进行插入和删除，但在另一端只允许删除的双端队列
* 5.队列的应用
* 队列的主要应用包括二叉树的层次遍历，打印系统中的作业排队，多用户对cpu资源的请求
* 队列广泛应用于计算机系统中，主机和外设速度不匹配的问题，多用户对资源的竞争问题


## 数组
* 数组是由n个(n>=1)相同类型的数据元素构成的有限序列
* 数组是线性表的推广，线性表可以看做一个一维数组
* 矩阵属于一种多维数组


## 树
* 1.树的概念
* 树是N个(N>=0)结点的有限集合，任意一颗非空树应该满足：
* 有且仅有一个根结点
* 当N大于1时，其余结点可分为m个互不相交的有限集合，每个集合也是一个树
* 树是一种递归的数据结构，具有以下特点：
* 树的根结点没有前驱结点，除根结点之外的所有结点有且只有一个前驱结点
* 树中所有结点都可以有零个或多个后继结点

* 2.基本术语
* 树中一个结点的子结点的个数称为该结点的度
* 树中结点的最大度数称为树的度
* 度大于0的结点称为分支结点
* 度等于0的结点称为叶子结点/终端结点
* 树的高度/深度是树中结点的最大层数
* 树中结点的子树是从左到右有次序且不能交换的树称为有序树
* 森林是m棵(m>=0)互不相交的树的集合

* 3.树的特点
* 度数之和==边数之和==结点数-1
* 高度为h的m叉树至多有(m^h-1)/(m-1)个结点


## 二叉树
* 二叉树是一种特殊的树，具有以下特点：
* 每个结点至多有两个子树，即二叉树中不存在度大于2的结点
* 二叉树是左右有序的，即左右子树有从左到右的次序
* 注意，二叉树不等于度为2的有序树，二者区别在于：
* 度为2的树至少有3个结点，而二叉树可以为空
* 度为2的树如果某个结点只有一个子结点就无序确定左右顺序，二叉树即使只有一个子结点也要确定左右
* 二叉树具有以下特点:
* 非空二叉树上叶子结点个数==度为2的结点数+1
* 高度为h的二叉树至多有2^h-1个结点

### 常见特殊二叉树
* 1.满二叉树
* 一个高度为h且含有2^h-1个结点的二叉树称为满二叉树
* 即树每一层的叶子结点都要长满
* 2.完全二叉树
* 一个高为h且有n个结点的二叉树，当且仅当每个结点与高为h的满二叉树的结点编号一一对应时称为完全二叉树
* 完全二叉树的最下面一层可能只有左结点，没有右结点，即度为1的结点个数只能是一个或者零个
* 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树
* 3.二叉排序树
* 二叉树的每个结点的左子树上所有结点的值均小于右子树上所有结点的值称为二叉排序树
* 4.平衡二叉树
* 二叉树的每个结点的左子树和右子树的高度之差不超过1称为平衡二叉树

### 二叉树的存储
* 1.顺序存储结构
* 采用连续的存储空间自上到下自左到右的存储结点元素，适合于存储满二叉树和完全二叉树
* 2.链式存储结构
* 每个结点除了存储结点数据以外，还包括左指针和右指针，即结构为lchild-data-rchild

### 二叉树的遍历
* 二叉树的遍历是指按照某条搜索路径访问树中的每个结点，使得每个结点被访问且仅被访问一次
* 1.先序遍历(preorder) NLR(中左右)
* 访问根结点
* 先序遍历左子树
* 先序遍历右子树
* 2.中序遍历(inorder) LNR(左中右)
* 中序遍历左子树
* 访问根结点
* 中序遍历右子树
* 3.后续遍历(postorder) LRN(左右中)
* 后续遍历左子树
* 后续遍历右子树
* 访问根结点
* 4.非递归遍历
* 借助栈结构可以实现对树的非递归遍历
* 5.层次遍历
* 借助队列结构可以实现从左到右，从上到下的遍历，即遍历顺序与结点的编号顺序一致
* 先将根结点入队，然后出队，访问根结点
* 如果结点有子树，结点出队被访问后，将其左右孩子依次入队
* 如果结点没有子树，结点出队被访问后，继续从队列中出结点直到队列为空
* 6.由遍历序列还原二叉树
* 由先序序列和中序序列可以唯一确定一棵二叉树
* 由后序序列和中序序列可以唯一确定一棵二叉树
* 由层序序列和终须序列可以唯一确定一棵二叉树
* 由先序序列和后序序列无法唯一确定一棵二叉树

### 二叉树的应用
* 1.二叉排序树/二叉查找树(BST)
* 二叉排序树中，左子树所有结点值<根结点值<右子树所有结点值
* 即二叉排序树的中序遍历序列是一串由小到大的值
* 2.平衡二叉树(AVL)
* 树的高度增长过快会降低二叉排序树的性能
* 平衡二叉树可以保证任意结点的左右子树高度差都不超过1
* 3.哈夫曼树/最优二叉树(huffman)
* 在实际应用中，树的结点常被设置一个权重值，称为该结点的权
* 从树的根结点到任意结点的路径长度与该结点上权值的乘积称为该结点的带权路径长度
* 树中所有叶子结点的带权路径长度之和称为该树的带权路径长度
* 在含有N个带权叶子结点的树中，带权路径长度最小的组合方式称为哈夫曼树
* 利用哈夫曼树可以构造出长度最短的二进制前缀编码，即没有一个编码是另一编码的前缀
* 构造出的哈夫曼树具有以下特点：
* 每个带权结点都会成为叶子结点，而且权重值越小的结点到根结点的路径越长
* 构造过程中新建了N-1个分支结点，因此哈夫曼树中共有2N-1个结点
* 哈夫曼中所有结点的度都为2或0，即不存在度为1的结点


## 图
* 图是有限个顶点集和边集的关系的集合
* 注意，线性表可以是空表，树可以是空树，但图不可以是空图
* 顶点上边的个数称为度，有向图中度还分为出度和入度
* 在路径序列中顶点不出现重复的路径称为简单路径

### 常见的图
* 1.有向图
* 有向图的边集都是有向边组成的
* 2.无向图
* 无向图的边集都是无向边组成的
* 3.简单图
* 简单图中不存在重复的边，也不存在顶点到自身的边
* 4.多重图
* 多重图中两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联
* 5.完全图
* 完全图中任意两个顶点之间都存在边，n个顶点有n(n-1)条边
* 6.子图
* 如果图A的边集和顶点集都是图B边集和顶点集的子集，称图A是图B的子图
* 7.连通图
* 连通图中任意两个顶点之间都是连通的，n个顶点至少有n-1条边

### 图的遍历
* 图的遍历是指从某一顶点出发，对图中所有顶点访问且仅访问一次
* 1.广度优先搜索(BFS)
* 广度优先搜索类似于二叉树的层序遍历，每一步向前都尽可能地访问顶点
* 广度优先中不存在类似深度优先中的回退操作，因此不是一个递归算法，采用队列结构实现
* 2.深度优先搜索(DFS)
* 深度优先搜索类似于树的先序遍历，每一步向前都尽可能地访问顶点
* 深度优先搜索是一个递归算法，采用栈结构实现
